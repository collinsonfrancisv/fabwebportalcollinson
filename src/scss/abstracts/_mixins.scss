
/// Media Query Breakpoint Mixin
/// This is a mixin solution by Paul from https://paul.af/media-queries-and-breakpoints-in-scss
 @mixin respond-to ($expression) {
   /// A variable $direction is created and it stores the sliced $expression argument string from the 0 character index up until to the first character of the string
   $direction: str-slice($expression, 0, 1);
   /// A variable $point is created and it stores the sliced $expression argument string from the 2nd character index up until the last character of the string
   $point: str-slice($expression, 2);
   
   /// An if statement will check if map-has-key will return true by checking if the $point exists in $breakpoints maps defined in _variables partial
   @if map-has-key($breakpoints, $point) {
     /// if the condition is true the map value associated will be stored in $point
     $point: map-get($breakpoints, $point);
 
   }
   
   /// An if-else statement that will provide the corresponding min-max prefix in the media query
   @if $direction == ">" {
       
     $direction: min;
 
   } @else if $direction == "<" {
 
     $direction: max;
 
   }  @else {
 
       @error "Expected < or >, got: #{$direction}";

   }
 
   @media (#{$direction}-width: #{$point} ) {
     @content;
   }
 }

/**
 * ~ Breakpoints mixin
 */ 

@mixin for-phone-only {
  @media (max-width: 49.9rem) { @content; }
}
@mixin for-tablet-portrait-up {
  @media (min-width: 60rem) { @content; }
}
@mixin for-tablet-portait-only {
  @media (min-width: 60rem) and (max-width: 79.9rem) { @content; }
}
@mixin for-tablet-landscape-up {
  @media (min-width: 80rem) { @content; }
}
@mixin for-tablet-landscape-only {
  @media (min-width: 800px) and (max-width: 119.9rem) { @content; }
}
@mixin for-desktop-up {
  @media (min-width: 120rem) { @content; }
}
@mixin for-desktop-only {
  @media (min-width: 120rem) and (max-width: 179.9rem) { @content; }
}
@mixin for-big-desktop-up {
  @media (min-width: 180rem) { @content; }
}
/**
 * ~ Visual Composition Mixins
 */ 

// Padding mixin
@mixin padding($left, $top, $right, $bottom) {
  padding-left: $left;
  padding-top: $top;
  padding-right: $right;
  padding-bottom: $bottom;
}
// Margin mixin
@mixin margin($left, $top, $right, $bottom) {
  margin-left: $left;
  margin-top: $top;
  margin-right: $right;
  margin-bottom: $bottom;
}

 /// Shadow styles
 /// Generate predefined box shadow orientation and shadow color declared in ui shadow maps sections in _variables.scss
 @mixin generate-box-shadow($shadow-orientation, $shadow-color) {
    -webkit-box-shadow: map-get($shadow-orientations, $shadow-orientation) map-get($shadow-colors, $shadow-color);
    -moz-box-shadow:    map-get($shadow-orientations, $shadow-orientation) map-get($shadow-colors, $shadow-color);
     box-shadow:        map-get($shadow-orientations, $shadow-orientation) map-get($shadow-colors, $shadow-color);
 }





 /// Border radius (all sides) generator
 @mixin generate-border-radius($radius) {
  border-radius: $radius;
  -webkit-border-radius: $radius;
	-moz-border-radius: $radius;
 }

 /// Border radii (explicit sides) generator
 @mixin generate-border-radii($topleft: null, $topright: null, $bottomright: null, $bottomleft: null) {
  @if $topleft != null and $topleft >= 0 {
    border-top-left-radius: $topleft;;
    -webkit-border-top-left-radius: $topleft;
    -moz-border-radius-topleft: $topleft;
  }

  @if $topright != null and $topright >= 0 {
    border-top-right-radius: $topright;
    -webkit-border-top-right-radius: $topright;
    -moz-border-radius-topright: $topright;
  }

  @if $bottomleft != null and $bottomleft >= 0 {
    border-bottom-left-radius: $bottomleft;
    -webkit-border-bottom-left-radius: $bottomleft;
    -moz-border-radius-bottomleft: $bottomleft;
  }

  @if $bottomright != null and $bottomright >= 0 {
    border-bottom-right-radius: $bottomright;
    -webkit-border-bottom-right-radius: $bottomright;
    -moz-border-radius-bottomright: $bottomright;
  }
}



 /// Flexbox declaration 
 @mixin flexbox($flex-direction: row, $flex-wrap: nowrap, $justify: center) {   
   display: flex;
   @if $flex-direction == row {

     flex-direction: row;

   } @else if $flex-direction == row-reverse {

     flex-direction: row-reverse;

   } @else if $flex-direction == column {

     flex-direction: column;

   } @else if $flex-direction == column-reverse {

     flex-direction: column-reverse;

   }

   @if $justify == flex-start {

     justify-content: flex-start;

   } @else if $justify == flex-end {
 
     justify-content: flex-end;

   } @else if $justify == center {

     justify-content: center;

   } @else if $justify == space-between {

     justify-content: space-between;

   } @else if $justify == space-around {

     justify-content: space-around;

   } @else if $justify == space-evenly {

     justify-content: space-evenly;

   }
   

 }